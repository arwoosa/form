package repository

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/mongodb"
	"github.com/testcontainers/testcontainers-go/wait"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/arwoosa/form-service/internal/models"
)

type SessionRepositoryIntegrationTestSuite struct {
	suite.Suite
	container  testcontainers.Container
	client     *mongo.Client
	repository SessionRepository
	ctx        context.Context
}

func (suite *SessionRepositoryIntegrationTestSuite) SetupSuite() {
	var err error
	suite.ctx = context.Background()

	// Create MongoDB container
	suite.container, err = mongodb.Run(suite.ctx, "mongo:7",
		mongodb.WithUsername("testuser"),
		mongodb.WithPassword("testpass"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("Waiting for connections").
				WithOccurrence(1).
				WithStartupTimeout(60*time.Second),
		),
	)
	suite.Require().NoError(err)

	// Get connection string
	uri, err := suite.container.Endpoint(suite.ctx, "")
	suite.Require().NoError(err)

	// Format as MongoDB URI with authentication
	mongoURI := "mongodb://testuser:testpass@" + uri

	// Connect to MongoDB
	suite.client, err = mongo.Connect(suite.ctx, options.Client().ApplyURI(mongoURI))
	suite.Require().NoError(err)

	// Test connection
	err = suite.client.Ping(suite.ctx, nil)
	suite.Require().NoError(err)

	suite.repository = NewMongoSessionRepository(suite.client, "test_db")
}

func (suite *SessionRepositoryIntegrationTestSuite) TearDownSuite() {
	if suite.client != nil {
		if err := suite.client.Disconnect(suite.ctx); err != nil {
			suite.T().Logf("Failed to disconnect MongoDB client: %v", err)
		}
	}
	if suite.container != nil {
		if err := suite.container.Terminate(suite.ctx); err != nil {
			suite.T().Logf("Failed to terminate test container: %v", err)
		}
	}
}

func (suite *SessionRepositoryIntegrationTestSuite) SetupTest() {
	// Clean up the database before each test
	database := suite.client.Database("test_db")
	collections, err := database.ListCollectionNames(suite.ctx, nil)
	suite.Require().NoError(err)

	for _, collection := range collections {
		err := database.Collection(collection).Drop(suite.ctx)
		suite.Require().NoError(err)
	}
}

// testSession creates a test session for integration tests
func testSession() *models.Session {
	eventID := primitive.NewObjectID()

	return &models.Session{
		// ID will be auto-generated by repository
		EventID:   eventID,
		StartTime: time.Now().Add(time.Hour),
		EndTime:   time.Now().Add(2 * time.Hour),
	}
}

func (suite *SessionRepositoryIntegrationTestSuite) TestCreate() {
	// Test creating a new session
	session := testSession()
	// Don't set ID, let the repository generate it

	result, err := suite.repository.Create(suite.ctx, session)

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), result)
	assert.False(suite.T(), result.ID.IsZero())
	assert.Equal(suite.T(), session.EventID, result.EventID)
	assert.Equal(suite.T(), session.StartTime.Truncate(time.Second), result.StartTime.Truncate(time.Second))
	assert.NotZero(suite.T(), result.CreatedAt)
	assert.NotZero(suite.T(), result.UpdatedAt)
}

func (suite *SessionRepositoryIntegrationTestSuite) TestFindByID() {
	// Create a session first
	session := testSession()
	created, err := suite.repository.Create(suite.ctx, session)
	suite.Require().NoError(err)

	// Test finding by ID
	found, err := suite.repository.FindByID(suite.ctx, created.ID.Hex())

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), found)
	assert.Equal(suite.T(), created.ID, found.ID)
	assert.Equal(suite.T(), created.EventID, found.EventID)
	assert.Equal(suite.T(), created.StartTime.Truncate(time.Second), found.StartTime.Truncate(time.Second))
}

func (suite *SessionRepositoryIntegrationTestSuite) TestFindByEventID() {
	eventID := primitive.NewObjectID()

	// Create multiple sessions for the same event
	session1 := testSession()
	session1.EventID = eventID
	session1.StartTime = time.Now().Add(time.Hour)
	session1.EndTime = time.Now().Add(2 * time.Hour)

	session2 := testSession()
	session2.EventID = eventID
	session2.StartTime = time.Now().Add(3 * time.Hour)
	session2.EndTime = time.Now().Add(4 * time.Hour)

	// Create session for different event
	session3 := testSession()
	session3.EventID = primitive.NewObjectID()
	session3.StartTime = time.Now().Add(5 * time.Hour)
	session3.EndTime = time.Now().Add(6 * time.Hour)

	_, err := suite.repository.Create(suite.ctx, session1)
	suite.Require().NoError(err)
	_, err = suite.repository.Create(suite.ctx, session2)
	suite.Require().NoError(err)
	_, err = suite.repository.Create(suite.ctx, session3)
	suite.Require().NoError(err)

	// Test finding by event ID
	results, err := suite.repository.FindByEventID(suite.ctx, eventID.Hex())

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), results)
	assert.Len(suite.T(), results, 2)

	// Verify all sessions belong to the correct event
	for _, session := range results {
		assert.Equal(suite.T(), eventID, session.EventID)
	}
}

func (suite *SessionRepositoryIntegrationTestSuite) TestUpdate() {
	// Create a session first
	session := testSession()
	created, err := suite.repository.Create(suite.ctx, session)
	suite.Require().NoError(err)

	// Update the session
	originalStartTime := created.StartTime
	created.StartTime = created.StartTime.Add(time.Hour)
	created.EndTime = created.EndTime.Add(time.Hour)

	updated, err := suite.repository.Update(suite.ctx, created.ID.Hex(), created)

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), updated)
	assert.True(suite.T(), updated.StartTime.After(originalStartTime))
	assert.True(suite.T(), updated.UpdatedAt.After(updated.CreatedAt))
}

func (suite *SessionRepositoryIntegrationTestSuite) TestDelete() {
	// Create a session first
	session := testSession()
	created, err := suite.repository.Create(suite.ctx, session)
	suite.Require().NoError(err)

	// Delete the session
	err = suite.repository.Delete(suite.ctx, created.ID.Hex())
	assert.NoError(suite.T(), err)

	// Verify it's deleted
	found, err := suite.repository.FindByID(suite.ctx, created.ID.Hex())
	assert.Error(suite.T(), err)
	assert.Nil(suite.T(), found)
}

func (suite *SessionRepositoryIntegrationTestSuite) TestCountByEventID() {
	eventID := primitive.NewObjectID()

	// Create multiple sessions for the event
	session1 := testSession()
	session1.EventID = eventID

	session2 := testSession()
	session2.EventID = eventID

	session3 := testSession()
	session3.EventID = eventID

	_, err := suite.repository.Create(suite.ctx, session1)
	suite.Require().NoError(err)
	_, err = suite.repository.Create(suite.ctx, session2)
	suite.Require().NoError(err)
	_, err = suite.repository.Create(suite.ctx, session3)
	suite.Require().NoError(err)

	// Test counting sessions for the event
	count, err := suite.repository.CountByEventID(suite.ctx, eventID.Hex())

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), int64(3), count)

	// Test counting for non-existent event
	nonExistentID := primitive.NewObjectID()
	count, err = suite.repository.CountByEventID(suite.ctx, nonExistentID.Hex())

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), int64(0), count)
}

func (suite *SessionRepositoryIntegrationTestSuite) TestExistsByID() {
	// Create a session
	session := testSession()
	created, err := suite.repository.Create(suite.ctx, session)
	suite.Require().NoError(err)

	// Test existence check for existing session
	exists, err := suite.repository.ExistsByID(suite.ctx, created.ID.Hex())
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), exists)

	// Test existence check for non-existent session
	objectID := primitive.NewObjectID()
	exists, err = suite.repository.ExistsByID(suite.ctx, objectID.Hex())
	assert.NoError(suite.T(), err)
	assert.False(suite.T(), exists)
}

func TestSessionRepositoryIntegrationTestSuite(t *testing.T) {
	suite.Run(t, new(SessionRepositoryIntegrationTestSuite))
}
