package repository

// import (
// 	"context"
// 	"testing"
// 	"time"

// 	"github.com/stretchr/testify/assert"
// 	"github.com/stretchr/testify/suite"
// 	"github.com/testcontainers/testcontainers-go"
// 	"github.com/testcontainers/testcontainers-go/modules/mongodb"
// 	"github.com/testcontainers/testcontainers-go/wait"
// 	"go.mongodb.org/mongo-driver/bson/primitive"
// 	"go.mongodb.org/mongo-driver/mongo"
// 	"go.mongodb.org/mongo-driver/mongo/options"

// 	"github.com/arwoosa/form-service/internal/models"
// )

// const (
// 	testMerchantID   = "test-merchant-id"
// 	statusPublished  = "published"
// 	statusDraft      = "draft"
// 	visibilityPublic = "public"
// )

// type EventRepositoryIntegrationTestSuite struct {
// 	suite.Suite
// 	container  testcontainers.Container
// 	client     *mongo.Client
// 	repository EventRepository
// 	ctx        context.Context
// }

// func (suite *EventRepositoryIntegrationTestSuite) SetupSuite() {
// 	var err error
// 	suite.ctx = context.Background()

// 	// Create MongoDB container
// 	suite.container, err = mongodb.Run(suite.ctx, "mongo:7",
// 		mongodb.WithUsername("testuser"),
// 		mongodb.WithPassword("testpass"),
// 		testcontainers.WithWaitStrategy(
// 			wait.ForLog("Waiting for connections").
// 				WithOccurrence(1).
// 				WithStartupTimeout(60*time.Second),
// 		),
// 	)
// 	suite.Require().NoError(err)

// 	// Get connection string
// 	uri, err := suite.container.Endpoint(suite.ctx, "")
// 	suite.Require().NoError(err)

// 	// Format as MongoDB URI with authentication
// 	mongoURI := "mongodb://testuser:testpass@" + uri

// 	// Connect to MongoDB
// 	suite.client, err = mongo.Connect(suite.ctx, options.Client().ApplyURI(mongoURI))
// 	suite.Require().NoError(err)

// 	// Test connection
// 	err = suite.client.Ping(suite.ctx, nil)
// 	suite.Require().NoError(err)

// 	suite.repository = NewMongoEventRepository(suite.client, "test_db", nil)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TearDownSuite() {
// 	if suite.client != nil {
// 		if err := suite.client.Disconnect(suite.ctx); err != nil {
// 			suite.T().Logf("Failed to disconnect MongoDB client: %v", err)
// 		}
// 	}
// 	if suite.container != nil {
// 		if err := suite.container.Terminate(suite.ctx); err != nil {
// 			suite.T().Logf("Failed to terminate test container: %v", err)
// 		}
// 	}
// }

// func (suite *EventRepositoryIntegrationTestSuite) SetupTest() {
// 	// Clean up the database before each test
// 	database := suite.client.Database("test_db")
// 	collections, err := database.ListCollectionNames(suite.ctx, nil)
// 	suite.Require().NoError(err)

// 	for _, collection := range collections {
// 		err := database.Collection(collection).Drop(suite.ctx)
// 		suite.Require().NoError(err)
// 	}
// }

// // testEvent creates a test event for integration tests
// func testEvent() *models.Event {
// 	merchantID := testMerchantID
// 	createdBy := primitive.NewObjectID()

// 	return &models.Event{
// 		// ID will be auto-generated by repository
// 		Title:         "Test Event",
// 		MerchantID:    merchantID,
// 		Summary:       "Test event summary",
// 		Status:        statusDraft,
// 		Visibility:    visibilityPublic,
// 		CoverImageURL: "https://example.com/cover.jpg",
// 		Location: models.Location{
// 			Name:    "Test Venue",
// 			Address: "123 Test Street, Test City",
// 			PlaceID: "test-place-id",
// 			Coordinates: models.GeoJSONPoint{
// 				Type:        "Point",
// 				Coordinates: [2]float64{121.5654, 25.0330},
// 			},
// 		},
// 		Detail: []models.DetailBlock{
// 			{
// 				Type: models.BlockTypeText,
// 				Data: models.TextData{Content: "Test event detail content"},
// 			},
// 		},
// 		FAQ:       []models.FAQ{},
// 		CreatedBy: createdBy,
// 		UpdatedBy: createdBy,
// 	}
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestCreate() {
// 	// Test creating a new event
// 	event := testEvent()
// 	// Don't set ID, let the repository generate it

// 	result, err := suite.repository.Create(suite.ctx, event)

// 	assert.NoError(suite.T(), err)
// 	assert.NotNil(suite.T(), result)
// 	assert.False(suite.T(), result.ID.IsZero())
// 	assert.Equal(suite.T(), event.MerchantID, result.MerchantID)
// 	assert.Equal(suite.T(), event.Title, result.Title)
// 	assert.Equal(suite.T(), event.Summary, result.Summary)
// 	assert.NotZero(suite.T(), result.CreatedAt)
// 	assert.NotZero(suite.T(), result.UpdatedAt)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestFindByID() {
// 	// Create an event first
// 	event := testEvent()
// 	created, err := suite.repository.Create(suite.ctx, event)
// 	suite.Require().NoError(err)

// 	// Test finding by ID
// 	found, err := suite.repository.FindByID(suite.ctx, created.ID.Hex())

// 	assert.NoError(suite.T(), err)
// 	assert.NotNil(suite.T(), found)
// 	assert.Equal(suite.T(), created.ID, found.ID)
// 	assert.Equal(suite.T(), created.Title, found.Title)
// 	assert.Equal(suite.T(), created.MerchantID, found.MerchantID)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestFindByIDNotFound() {
// 	// Test finding non-existent event
// 	objectID := primitive.NewObjectID()
// 	found, err := suite.repository.FindByID(suite.ctx, objectID.Hex())

// 	assert.Error(suite.T(), err)
// 	assert.Nil(suite.T(), found)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestUpdate() {
// 	// Create an event first
// 	event := testEvent()
// 	created, err := suite.repository.Create(suite.ctx, event)
// 	suite.Require().NoError(err)

// 	// Update the event
// 	created.Title = "Updated Event Title"
// 	created.Summary = "Updated summary"
// 	created.Status = statusPublished

// 	updated, err := suite.repository.Update(suite.ctx, created.ID.Hex(), created)

// 	assert.NoError(suite.T(), err)
// 	assert.NotNil(suite.T(), updated)
// 	assert.Equal(suite.T(), "Updated Event Title", updated.Title)
// 	assert.Equal(suite.T(), "Updated summary", updated.Summary)
// 	assert.Equal(suite.T(), statusPublished, updated.Status)
// 	assert.True(suite.T(), updated.UpdatedAt.After(updated.CreatedAt))
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestDelete() {
// 	// Create an event first
// 	event := testEvent()
// 	created, err := suite.repository.Create(suite.ctx, event)
// 	suite.Require().NoError(err)

// 	// Delete the event
// 	err = suite.repository.Delete(suite.ctx, created.ID.Hex())
// 	assert.NoError(suite.T(), err)

// 	// Verify it's deleted
// 	found, err := suite.repository.FindByID(suite.ctx, created.ID.Hex())
// 	assert.Error(suite.T(), err)
// 	assert.Nil(suite.T(), found)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestFindByMerchantID() {
// 	merchantID := testMerchantID

// 	// Create multiple events for the merchant
// 	event1 := testEvent()
// 	event1.MerchantID = merchantID
// 	event1.Title = "Event 1"
// 	event1.Status = statusDraft

// 	event2 := testEvent()
// 	event2.MerchantID = merchantID
// 	event2.Title = "Event 2"
// 	event2.Status = statusPublished

// 	// Create event for different merchant
// 	event3 := testEvent()
// 	event3.MerchantID = "other-merchant-id"
// 	event3.Title = "Other Event"

// 	_, err := suite.repository.Create(suite.ctx, event1)
// 	suite.Require().NoError(err)
// 	_, err = suite.repository.Create(suite.ctx, event2)
// 	suite.Require().NoError(err)
// 	_, err = suite.repository.Create(suite.ctx, event3)
// 	suite.Require().NoError(err)

// 	// Test finding by merchant ID
// 	filter := &EventFilter{
// 		MerchantID: &merchantID,
// 		Limit:      10,
// 		Offset:     0,
// 	}

// 	result, err := suite.repository.FindByMerchantID(suite.ctx, merchantID, filter)

// 	assert.NoError(suite.T(), err)
// 	assert.NotNil(suite.T(), result)
// 	assert.Len(suite.T(), result.Events, 2)

// 	// Verify all events belong to the correct merchant
// 	for _, event := range result.Events {
// 		assert.Equal(suite.T(), merchantID, event.MerchantID)
// 	}
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestFindByMerchantIDWithStatusFilter() {
// 	merchantID := testMerchantID
// 	status := statusPublished

// 	// Create events with different statuses
// 	event1 := testEvent()
// 	event1.MerchantID = merchantID
// 	event1.Status = statusDraft

// 	event2 := testEvent()
// 	event2.MerchantID = merchantID
// 	event2.Status = statusPublished

// 	_, err := suite.repository.Create(suite.ctx, event1)
// 	suite.Require().NoError(err)
// 	_, err = suite.repository.Create(suite.ctx, event2)
// 	suite.Require().NoError(err)

// 	// Test filtering by status
// 	filter := &EventFilter{
// 		MerchantID: &merchantID,
// 		Status:     &status,
// 		Limit:      10,
// 		Offset:     0,
// 	}

// 	result, err := suite.repository.FindByMerchantID(suite.ctx, merchantID, filter)

// 	assert.NoError(suite.T(), err)
// 	assert.NotNil(suite.T(), result)
// 	assert.Len(suite.T(), result.Events, 1)
// 	assert.Equal(suite.T(), statusPublished, result.Events[0].Status)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestFindPublic() {
// 	// Create public and private events
// 	publicEvent1 := testEvent()
// 	publicEvent1.Status = statusPublished
// 	publicEvent1.Visibility = visibilityPublic
// 	publicEvent1.Title = "Public Event 1"

// 	publicEvent2 := testEvent()
// 	publicEvent2.Status = statusPublished
// 	publicEvent2.Visibility = visibilityPublic
// 	publicEvent2.Title = "Public Event 2"

// 	privateEvent := testEvent()
// 	privateEvent.Status = statusPublished
// 	privateEvent.Visibility = "private"
// 	privateEvent.Title = "Private Event"

// 	draftEvent := testEvent()
// 	draftEvent.Status = statusDraft
// 	draftEvent.Visibility = visibilityPublic
// 	draftEvent.Title = "Draft Event"

// 	_, err := suite.repository.Create(suite.ctx, publicEvent1)
// 	suite.Require().NoError(err)
// 	_, err = suite.repository.Create(suite.ctx, publicEvent2)
// 	suite.Require().NoError(err)
// 	_, err = suite.repository.Create(suite.ctx, privateEvent)
// 	suite.Require().NoError(err)
// 	_, err = suite.repository.Create(suite.ctx, draftEvent)
// 	suite.Require().NoError(err)

// 	// Test finding public events
// 	filter := &PublicEventFilter{
// 		Limit:  10,
// 		Offset: 0,
// 	}

// 	result, err := suite.repository.FindPublic(suite.ctx, filter)

// 	assert.NoError(suite.T(), err)
// 	assert.NotNil(suite.T(), result)
// 	assert.Len(suite.T(), result.Events, 2)

// 	// Verify all events are public and published
// 	for _, event := range result.Events {
// 		assert.Equal(suite.T(), statusPublished, event.Status)
// 		assert.Equal(suite.T(), visibilityPublic, event.Visibility)
// 	}
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestExistsByID() {
// 	// Create an event
// 	event := testEvent()
// 	created, err := suite.repository.Create(suite.ctx, event)
// 	suite.Require().NoError(err)

// 	// Test existence check for existing event
// 	exists, err := suite.repository.ExistsByID(suite.ctx, created.ID.Hex())
// 	assert.NoError(suite.T(), err)
// 	assert.True(suite.T(), exists)

// 	// Test existence check for non-existent event
// 	objectID := primitive.NewObjectID()
// 	exists, err = suite.repository.ExistsByID(suite.ctx, objectID.Hex())
// 	assert.NoError(suite.T(), err)
// 	assert.False(suite.T(), exists)
// }

// func (suite *EventRepositoryIntegrationTestSuite) TestExistsByMerchantAndID() {
// 	merchantID := testMerchantID

// 	// Create an event
// 	event := testEvent()
// 	event.MerchantID = merchantID
// 	created, err := suite.repository.Create(suite.ctx, event)
// 	suite.Require().NoError(err)

// 	// Test existence check for correct merchant and ID
// 	exists, err := suite.repository.ExistsByMerchantAndID(suite.ctx, merchantID, created.ID.Hex())
// 	assert.NoError(suite.T(), err)
// 	assert.True(suite.T(), exists)

// 	// Test existence check for wrong merchant
// 	exists, err = suite.repository.ExistsByMerchantAndID(suite.ctx, "wrong-merchant", created.ID.Hex())
// 	assert.NoError(suite.T(), err)
// 	assert.False(suite.T(), exists)

// 	// Test existence check for non-existent event
// 	objectID := primitive.NewObjectID()
// 	exists, err = suite.repository.ExistsByMerchantAndID(suite.ctx, merchantID, objectID.Hex())
// 	assert.NoError(suite.T(), err)
// 	assert.False(suite.T(), exists)
// }

// func TestEventRepositoryIntegrationTestSuite(t *testing.T) {
// 	suite.Run(t, new(EventRepositoryIntegrationTestSuite))
// }
